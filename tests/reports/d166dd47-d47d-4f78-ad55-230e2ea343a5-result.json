{"name": "test_city", "status": "broken", "statusDetails": {"message": "KeyError: 'city'", "trace": "self = Index(['Account_Num', 'Provider Name', 'Provider Street Address',\n       'Provider City', 'Provider State', 'Provider ...arges', 'Average Covered Charges', 'Average Total Payments',\n       'Average Medicare Payments'],\n      dtype='object')\nkey = 'city', method = None, tolerance = None\n\n    def get_loc(self, key, method=None, tolerance=None):\n        \"\"\"\n        Get integer location, slice or boolean mask for requested label.\n    \n        Parameters\n        ----------\n        key : label\n        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n            * default: exact matches only.\n            * pad / ffill: find the PREVIOUS index value if no exact match.\n            * backfill / bfill: use NEXT index value if no exact match\n            * nearest: use the NEAREST index value if no exact match. Tied\n              distances are broken by preferring the larger index value.\n        tolerance : int or float, optional\n            Maximum distance from index value for inexact matches. The value of\n            the index at the matching location must satisfy the equation\n            ``abs(index[loc] - key) <= tolerance``.\n    \n        Returns\n        -------\n        loc : int if unique index, slice if monotonic index, else mask\n    \n        Examples\n        --------\n        >>> unique_index = pd.Index(list('abc'))\n        >>> unique_index.get_loc('b')\n        1\n    \n        >>> monotonic_index = pd.Index(list('abbc'))\n        >>> monotonic_index.get_loc('b')\n        slice(1, 3, None)\n    \n        >>> non_monotonic_index = pd.Index(list('abcb'))\n        >>> non_monotonic_index.get_loc('b')\n        array([False,  True, False,  True])\n        \"\"\"\n        if method is None:\n            if tolerance is not None:\n                raise ValueError(\n                    \"tolerance argument only valid if using pad, \"\n                    \"backfill or nearest lookups\"\n                )\n            casted_key = self._maybe_cast_indexer(key)\n            try:\n>               return self._engine.get_loc(casted_key)\n\n..\\lib\\site-packages\\pandas\\core\\indexes\\base.py:3361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\index.pyx:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\index.pyx:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\hashtable_class_helper.pxi:5198: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\nE   KeyError: 'city'\n\npandas\\_libs\\hashtable_class_helper.pxi:5206: KeyError\n\nThe above exception was the direct cause of the following exception:\n\ndf =       Account_Num                                      Provider Name  ... Average Total Payments Average Medicare Paym...TT & WHITE MEDICAL CENTER - MARBLE F...  ...                4650.44                   3500.67\n\n[2697 rows x 10 columns]\n\n    def test_city(df):\n>       dt.validate.regex(df['city'],r'^[a-zA-Z]')\n\ncsvfilecheck.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\lib\\site-packages\\pandas\\core\\frame.py:3455: in __getitem__\n    indexer = self.columns.get_loc(key)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Index(['Account_Num', 'Provider Name', 'Provider Street Address',\n       'Provider City', 'Provider State', 'Provider ...arges', 'Average Covered Charges', 'Average Total Payments',\n       'Average Medicare Payments'],\n      dtype='object')\nkey = 'city', method = None, tolerance = None\n\n    def get_loc(self, key, method=None, tolerance=None):\n        \"\"\"\n        Get integer location, slice or boolean mask for requested label.\n    \n        Parameters\n        ----------\n        key : label\n        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n            * default: exact matches only.\n            * pad / ffill: find the PREVIOUS index value if no exact match.\n            * backfill / bfill: use NEXT index value if no exact match\n            * nearest: use the NEAREST index value if no exact match. Tied\n              distances are broken by preferring the larger index value.\n        tolerance : int or float, optional\n            Maximum distance from index value for inexact matches. The value of\n            the index at the matching location must satisfy the equation\n            ``abs(index[loc] - key) <= tolerance``.\n    \n        Returns\n        -------\n        loc : int if unique index, slice if monotonic index, else mask\n    \n        Examples\n        --------\n        >>> unique_index = pd.Index(list('abc'))\n        >>> unique_index.get_loc('b')\n        1\n    \n        >>> monotonic_index = pd.Index(list('abbc'))\n        >>> monotonic_index.get_loc('b')\n        slice(1, 3, None)\n    \n        >>> non_monotonic_index = pd.Index(list('abcb'))\n        >>> non_monotonic_index.get_loc('b')\n        array([False,  True, False,  True])\n        \"\"\"\n        if method is None:\n            if tolerance is not None:\n                raise ValueError(\n                    \"tolerance argument only valid if using pad, \"\n                    \"backfill or nearest lookups\"\n                )\n            casted_key = self._maybe_cast_indexer(key)\n            try:\n                return self._engine.get_loc(casted_key)\n            except KeyError as err:\n>               raise KeyError(key) from err\nE               KeyError: 'city'\n\n..\\lib\\site-packages\\pandas\\core\\indexes\\base.py:3363: KeyError"}, "start": 1630685586221, "stop": 1630685586222, "uuid": "5a21a039-d278-4275-991b-0ace846d4848", "historyId": "f0a6626780aa7176aae7b4032f205ead", "testCaseId": "bfe1330ff22bca33cecd589f31ea18df", "fullName": "csvfilecheck#test_city", "labels": [{"name": "suite", "value": "csvfilecheck"}, {"name": "host", "value": "DOA-DOIT-CONSL1"}, {"name": "thread", "value": "6716-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "csvfilecheck"}]}