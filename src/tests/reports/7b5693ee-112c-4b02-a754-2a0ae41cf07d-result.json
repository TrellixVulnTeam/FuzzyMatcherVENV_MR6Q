{"name": "test_Address", "status": "broken", "statusDetails": {"message": "FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Work_Imp\\\\DataScience\\\\FuzzyMatcherVENV\\\\data\\\\raw\\\\hospital_reimbursements.csv'", "trace": "@allure.story('Testing CSV File')\n    @allure.feature('Testing path of the CSV file and Extension')\n    @allure.testcase(\"CSV Test Case\")\n    @pytest.fixture(scope='module')\n    @dt.working_directory(__file__)\n    def df():\n>       return pd.read_csv('C:\\\\Work_Imp\\\\DataScience\\\\FuzzyMatcherVENV\\\\data\\\\raw\\\\hospital_reimbursements.csv')\n\ncsvfilecheck.py:17: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\lib\\site-packages\\pandas\\util\\_decorators.py:311: in wrapper\n    return func(*args, **kwargs)\n..\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:586: in read_csv\n    return _read(filepath_or_buffer, kwds)\n..\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:482: in _read\n    parser = TextFileReader(filepath_or_buffer, **kwds)\n..\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:811: in __init__\n    self._engine = self._make_engine(self.engine)\n..\\lib\\site-packages\\pandas\\io\\parsers\\readers.py:1040: in _make_engine\n    return mapping[engine](self.f, **self.options)  # type: ignore[call-arg]\n..\\lib\\site-packages\\pandas\\io\\parsers\\c_parser_wrapper.py:51: in __init__\n    self._open_handles(src, kwds)\n..\\lib\\site-packages\\pandas\\io\\parsers\\base_parser.py:222: in _open_handles\n    self.handles = get_handle(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\npath_or_buf = 'C:\\\\Work_Imp\\\\DataScience\\\\FuzzyMatcherVENV\\\\data\\\\raw\\\\hospital_reimbursements.csv', mode = 'r', encoding = 'utf-8'\ncompression = None, memory_map = False, is_text = True, errors = 'strict', storage_options = None\n\n    def get_handle(\n        path_or_buf: FilePathOrBuffer,\n        mode: str,\n        encoding: str | None = None,\n        compression: CompressionOptions = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n        errors: str | None = None,\n        storage_options: StorageOptions = None,\n    ) -> IOHandles:\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is one of\n            {'zip', 'gzip', 'bz2'}, or inferred as one of the above,\n            other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n            .. versionchanged:: 1.1.0\n    \n               Passing compression options as keys in dict is now\n               supported for compression modes 'gzip' and 'bz2' as well as 'zip'.\n    \n        memory_map : bool, default False\n            See parsers._parser_params for more information.\n        is_text : bool, default True\n            Whether the type of the content passed to the file/buffer is string or\n            bytes. This is not the same as `\"b\" not in mode`. If a string content is\n            passed to a binary file/buffer, a wrapper is inserted.\n        errors : str, default 'strict'\n            Specifies how encoding and decoding errors are to be handled.\n            See the errors argument for :func:`open` for a full list\n            of options.\n        storage_options: StorageOptions = None\n            Passed to _get_filepath_or_buffer\n    \n        .. versionchanged:: 1.2.0\n    \n        Returns the dataclass IOHandles\n        \"\"\"\n        # Windows does not default to utf-8. Set to utf-8 for a consistent behavior\n        encoding = encoding or \"utf-8\"\n    \n        # read_csv does not know whether the buffer is opened in binary/text mode\n        if _is_binary_mode(path_or_buf, mode) and \"b\" not in mode:\n            mode += \"b\"\n    \n        # valdiate errors\n        if isinstance(errors, str):\n            errors = errors.lower()\n        if errors not in (\n            None,\n            \"strict\",\n            \"ignore\",\n            \"replace\",\n            \"xmlcharrefreplace\",\n            \"backslashreplace\",\n            \"namereplace\",\n            \"surrogateescape\",\n            \"surrogatepass\",\n        ):\n            raise ValueError(\n                f\"Invalid value for `encoding_errors` ({errors}). Please see \"\n                + \"https://docs.python.org/3/library/codecs.html#error-handlers \"\n                + \"for valid values.\"\n            )\n    \n        # open URLs\n        ioargs = _get_filepath_or_buffer(\n            path_or_buf,\n            encoding=encoding,\n            compression=compression,\n            mode=mode,\n            storage_options=storage_options,\n        )\n    \n        handle = ioargs.filepath_or_buffer\n        handles: list[Buffer]\n    \n        # memory mapping needs to be the first step\n        handle, memory_map, handles = _maybe_memory_map(\n            handle,\n            memory_map,\n            ioargs.encoding,\n            ioargs.mode,\n            errors,\n            ioargs.compression[\"method\"] not in _compression_to_extension,\n        )\n    \n        is_path = isinstance(handle, str)\n        compression_args = dict(ioargs.compression)\n        compression = compression_args.pop(\"method\")\n    \n        if compression:\n            # compression libraries do not like an explicit text-mode\n            ioargs.mode = ioargs.mode.replace(\"t\", \"\")\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    assert isinstance(handle, str)\n                    handle = gzip.GzipFile(\n                        filename=handle,\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n                else:\n                    handle = gzip.GzipFile(\n                        # error: Argument \"fileobj\" to \"GzipFile\" has incompatible type\n                        # \"Union[str, Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase,\n                        # TextIOWrapper, mmap]]\"; expected \"Optional[IO[bytes]]\"\n                        fileobj=handle,  # type: ignore[arg-type]\n                        mode=ioargs.mode,\n                        **compression_args,\n                    )\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                handle = bz2.BZ2File(\n                    # Argument 1 to \"BZ2File\" has incompatible type \"Union[str,\n                    # Union[IO[Any], RawIOBase, BufferedIOBase, TextIOBase, TextIOWrapper,\n                    # mmap]]\"; expected \"Union[Union[str, bytes, _PathLike[str],\n                    # _PathLike[bytes]], IO[bytes]]\"\n                    handle,  # type: ignore[arg-type]\n                    mode=ioargs.mode,\n                    **compression_args,\n                )\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                handle = _BytesZipFile(handle, ioargs.mode, **compression_args)\n                if handle.mode == \"r\":\n                    handles.append(handle)\n                    zip_names = handle.namelist()\n                    if len(zip_names) == 1:\n                        handle = handle.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file. \"\n                            f\"Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                handle = get_lzma_file(lzma)(handle, ioargs.mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            assert not isinstance(handle, str)\n            handles.append(handle)\n    \n        elif isinstance(handle, str):\n            # Check whether the filename is to be opened in binary mode.\n            # Binary mode does not support 'encoding' and 'newline'.\n            if ioargs.encoding and \"b\" not in ioargs.mode:\n                # Encoding\n>               handle = open(\n                    handle,\n                    ioargs.mode,\n                    encoding=ioargs.encoding,\n                    errors=errors,\n                    newline=\"\",\n                )\nE               FileNotFoundError: [Errno 2] No such file or directory: 'C:\\\\Work_Imp\\\\DataScience\\\\FuzzyMatcherVENV\\\\data\\\\raw\\\\hospital_reimbursements.csv'\n\n..\\lib\\site-packages\\pandas\\io\\common.py:701: FileNotFoundError"}, "start": 1630684335486, "stop": 1630684335486, "uuid": "061574bc-3fdc-4dad-9cb6-60842c9c0893", "historyId": "8ef380f0c2dccb7163949639749fd0bc", "testCaseId": "472f325fd37d465846a091a4117d3536", "fullName": "csvfilecheck#test_Address", "labels": [{"name": "severity", "value": "minor"}, {"name": "suite", "value": "csvfilecheck"}, {"name": "host", "value": "DOA-DOIT-CONSL1"}, {"name": "thread", "value": "22216-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "csvfilecheck"}]}