{"name": "test_Address", "status": "broken", "statusDetails": {"message": "KeyError: 'Address'", "trace": "self = Index(['Account_Num', 'Provider Name', 'Provider Street Address',\n       'Provider City', 'Provider State', 'Provider ...arges', 'Average Covered Charges', 'Average Total Payments',\n       'Average Medicare Payments'],\n      dtype='object')\nkey = 'Address', method = None, tolerance = None\n\n    def get_loc(self, key, method=None, tolerance=None):\n        \"\"\"\n        Get integer location, slice or boolean mask for requested label.\n    \n        Parameters\n        ----------\n        key : label\n        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n            * default: exact matches only.\n            * pad / ffill: find the PREVIOUS index value if no exact match.\n            * backfill / bfill: use NEXT index value if no exact match\n            * nearest: use the NEAREST index value if no exact match. Tied\n              distances are broken by preferring the larger index value.\n        tolerance : int or float, optional\n            Maximum distance from index value for inexact matches. The value of\n            the index at the matching location must satisfy the equation\n            ``abs(index[loc] - key) <= tolerance``.\n    \n        Returns\n        -------\n        loc : int if unique index, slice if monotonic index, else mask\n    \n        Examples\n        --------\n        >>> unique_index = pd.Index(list('abc'))\n        >>> unique_index.get_loc('b')\n        1\n    \n        >>> monotonic_index = pd.Index(list('abbc'))\n        >>> monotonic_index.get_loc('b')\n        slice(1, 3, None)\n    \n        >>> non_monotonic_index = pd.Index(list('abcb'))\n        >>> non_monotonic_index.get_loc('b')\n        array([False,  True, False,  True])\n        \"\"\"\n        if method is None:\n            if tolerance is not None:\n                raise ValueError(\n                    \"tolerance argument only valid if using pad, \"\n                    \"backfill or nearest lookups\"\n                )\n            casted_key = self._maybe_cast_indexer(key)\n            try:\n>               return self._engine.get_loc(casted_key)\n\n..\\lib\\site-packages\\pandas\\core\\indexes\\base.py:3361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\index.pyx:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\index.pyx:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\hashtable_class_helper.pxi:5198: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\nE   KeyError: 'Address'\n\npandas\\_libs\\hashtable_class_helper.pxi:5206: KeyError\n\nThe above exception was the direct cause of the following exception:\n\ndf =       Account_Num                                      Provider Name  ... Average Total Payments Average Medicare Paym...TT & WHITE MEDICAL CENTER - MARBLE F...  ...                4650.44                   3500.67\n\n[2697 rows x 10 columns]\n\n    @allure.step(\"Verify the address column\")\n    @allure.severity(allure.severity_level.MINOR)\n    def test_Address(df):\n>       dt.validate.regex(df['Address'],r'^[a-zA-Z0-9]')\n\ncsvfilecheck.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\lib\\site-packages\\pandas\\core\\frame.py:3455: in __getitem__\n    indexer = self.columns.get_loc(key)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Index(['Account_Num', 'Provider Name', 'Provider Street Address',\n       'Provider City', 'Provider State', 'Provider ...arges', 'Average Covered Charges', 'Average Total Payments',\n       'Average Medicare Payments'],\n      dtype='object')\nkey = 'Address', method = None, tolerance = None\n\n    def get_loc(self, key, method=None, tolerance=None):\n        \"\"\"\n        Get integer location, slice or boolean mask for requested label.\n    \n        Parameters\n        ----------\n        key : label\n        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n            * default: exact matches only.\n            * pad / ffill: find the PREVIOUS index value if no exact match.\n            * backfill / bfill: use NEXT index value if no exact match\n            * nearest: use the NEAREST index value if no exact match. Tied\n              distances are broken by preferring the larger index value.\n        tolerance : int or float, optional\n            Maximum distance from index value for inexact matches. The value of\n            the index at the matching location must satisfy the equation\n            ``abs(index[loc] - key) <= tolerance``.\n    \n        Returns\n        -------\n        loc : int if unique index, slice if monotonic index, else mask\n    \n        Examples\n        --------\n        >>> unique_index = pd.Index(list('abc'))\n        >>> unique_index.get_loc('b')\n        1\n    \n        >>> monotonic_index = pd.Index(list('abbc'))\n        >>> monotonic_index.get_loc('b')\n        slice(1, 3, None)\n    \n        >>> non_monotonic_index = pd.Index(list('abcb'))\n        >>> non_monotonic_index.get_loc('b')\n        array([False,  True, False,  True])\n        \"\"\"\n        if method is None:\n            if tolerance is not None:\n                raise ValueError(\n                    \"tolerance argument only valid if using pad, \"\n                    \"backfill or nearest lookups\"\n                )\n            casted_key = self._maybe_cast_indexer(key)\n            try:\n                return self._engine.get_loc(casted_key)\n            except KeyError as err:\n>               raise KeyError(key) from err\nE               KeyError: 'Address'\n\n..\\lib\\site-packages\\pandas\\core\\indexes\\base.py:3363: KeyError"}, "steps": [{"name": "Verify the address column", "status": "broken", "statusDetails": {"message": "KeyError: 'Address'\n", "trace": "  File \"C:\\Work_Imp\\DataScience\\FuzzyMatcherVENV\\lib\\site-packages\\allure_commons\\_allure.py\", line 172, in impl\n    return func(*a, **kw)\n  File \"C:\\Work_Imp\\DataScience\\FuzzyMatcherVENV\\tests\\csvfilecheck.py\", line 30, in test_Address\n    dt.validate.regex(df['Address'],r'^[a-zA-Z0-9]')\n  File \"C:\\Work_Imp\\DataScience\\FuzzyMatcherVENV\\lib\\site-packages\\pandas\\core\\frame.py\", line 3455, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"C:\\Work_Imp\\DataScience\\FuzzyMatcherVENV\\lib\\site-packages\\pandas\\core\\indexes\\base.py\", line 3363, in get_loc\n    raise KeyError(key) from err\n"}, "parameters": [{"name": "df", "value": "      Account_Num  ... Average Medicare Payments\n0          839987  ...                   4115.52\n1          519118  ...                   4490.93\n2          733073  ...                   4021.79\n3          201752  ...                   4284.17\n4          678488  ...                   4819.53\n...           ...  ...                       ...\n2692       403227  ...                   3927.62\n2693       797810  ...                   4423.52\n2694       611900  ...                   4497.16\n2695       693781  ...                   4531.37\n2696       322584  ...                   3500.67\n\n[2697 rows x 10 columns]"}], "start": 1630685211696, "stop": 1630685211697}], "start": 1630685211685, "stop": 1630685211701, "uuid": "c6e60cf2-6070-4780-998f-46cba8699e0e", "historyId": "8ef380f0c2dccb7163949639749fd0bc", "testCaseId": "472f325fd37d465846a091a4117d3536", "fullName": "csvfilecheck#test_Address", "labels": [{"name": "severity", "value": "minor"}, {"name": "suite", "value": "csvfilecheck"}, {"name": "host", "value": "DOA-DOIT-CONSL1"}, {"name": "thread", "value": "21440-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "csvfilecheck"}]}