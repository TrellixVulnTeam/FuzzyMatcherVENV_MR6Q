{"name": "test_Facility_Name", "status": "broken", "statusDetails": {"message": "KeyError: 'Facility Name'", "trace": "self = Index(['Account_Num', 'FacilityName', 'Address', 'City', 'State', 'ZIPCode',\n       'County Name', 'Phone Number', 'Hospital Type', 'Hospital Ownership'],\n      dtype='object')\nkey = 'Facility Name', method = None, tolerance = None\n\n    def get_loc(self, key, method=None, tolerance=None):\n        \"\"\"\n        Get integer location, slice or boolean mask for requested label.\n    \n        Parameters\n        ----------\n        key : label\n        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n            * default: exact matches only.\n            * pad / ffill: find the PREVIOUS index value if no exact match.\n            * backfill / bfill: use NEXT index value if no exact match\n            * nearest: use the NEAREST index value if no exact match. Tied\n              distances are broken by preferring the larger index value.\n        tolerance : int or float, optional\n            Maximum distance from index value for inexact matches. The value of\n            the index at the matching location must satisfy the equation\n            ``abs(index[loc] - key) <= tolerance``.\n    \n        Returns\n        -------\n        loc : int if unique index, slice if monotonic index, else mask\n    \n        Examples\n        --------\n        >>> unique_index = pd.Index(list('abc'))\n        >>> unique_index.get_loc('b')\n        1\n    \n        >>> monotonic_index = pd.Index(list('abbc'))\n        >>> monotonic_index.get_loc('b')\n        slice(1, 3, None)\n    \n        >>> non_monotonic_index = pd.Index(list('abcb'))\n        >>> non_monotonic_index.get_loc('b')\n        array([False,  True, False,  True])\n        \"\"\"\n        if method is None:\n            if tolerance is not None:\n                raise ValueError(\n                    \"tolerance argument only valid if using pad, \"\n                    \"backfill or nearest lookups\"\n                )\n            casted_key = self._maybe_cast_indexer(key)\n            try:\n>               return self._engine.get_loc(casted_key)\n\nC:\\Users\\Vijay.Sriramoju.CTR\\Anaconda3\\envs\\FuzzyNameMatching\\lib\\site-packages\\pandas\\core\\indexes\\base.py:3361: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\index.pyx:76: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\index.pyx:108: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\n\npandas\\_libs\\hashtable_class_helper.pxi:5198: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n>   ???\nE   KeyError: 'Facility Name'\n\npandas\\_libs\\hashtable_class_helper.pxi:5206: KeyError\n\nThe above exception was the direct cause of the following exception:\n\ndf =       Account_Num                       FacilityName  ...              Hospital Type              Hospital Ownership\n0...      I-70 COMMUNITY HOSPITAL  ...  Critical Access Hospitals                     Proprietary\n\n[5339 rows x 10 columns]\n\n    @allure.step(\"Verify the Facility Name column\")\n    @allure.severity(allure.severity_level.MINOR)\n    def test_Facility_Name(df):\n>       dt.validate.regex(df['Facility Name'],r'^[a-zA-Z0-9()]')\n\ncsvfilecheck.py:63: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\Vijay.Sriramoju.CTR\\Anaconda3\\envs\\FuzzyNameMatching\\lib\\site-packages\\pandas\\core\\frame.py:3455: in __getitem__\n    indexer = self.columns.get_loc(key)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Index(['Account_Num', 'FacilityName', 'Address', 'City', 'State', 'ZIPCode',\n       'County Name', 'Phone Number', 'Hospital Type', 'Hospital Ownership'],\n      dtype='object')\nkey = 'Facility Name', method = None, tolerance = None\n\n    def get_loc(self, key, method=None, tolerance=None):\n        \"\"\"\n        Get integer location, slice or boolean mask for requested label.\n    \n        Parameters\n        ----------\n        key : label\n        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n            * default: exact matches only.\n            * pad / ffill: find the PREVIOUS index value if no exact match.\n            * backfill / bfill: use NEXT index value if no exact match\n            * nearest: use the NEAREST index value if no exact match. Tied\n              distances are broken by preferring the larger index value.\n        tolerance : int or float, optional\n            Maximum distance from index value for inexact matches. The value of\n            the index at the matching location must satisfy the equation\n            ``abs(index[loc] - key) <= tolerance``.\n    \n        Returns\n        -------\n        loc : int if unique index, slice if monotonic index, else mask\n    \n        Examples\n        --------\n        >>> unique_index = pd.Index(list('abc'))\n        >>> unique_index.get_loc('b')\n        1\n    \n        >>> monotonic_index = pd.Index(list('abbc'))\n        >>> monotonic_index.get_loc('b')\n        slice(1, 3, None)\n    \n        >>> non_monotonic_index = pd.Index(list('abcb'))\n        >>> non_monotonic_index.get_loc('b')\n        array([False,  True, False,  True])\n        \"\"\"\n        if method is None:\n            if tolerance is not None:\n                raise ValueError(\n                    \"tolerance argument only valid if using pad, \"\n                    \"backfill or nearest lookups\"\n                )\n            casted_key = self._maybe_cast_indexer(key)\n            try:\n                return self._engine.get_loc(casted_key)\n            except KeyError as err:\n>               raise KeyError(key) from err\nE               KeyError: 'Facility Name'\n\nC:\\Users\\Vijay.Sriramoju.CTR\\Anaconda3\\envs\\FuzzyNameMatching\\lib\\site-packages\\pandas\\core\\indexes\\base.py:3363: KeyError"}, "steps": [{"name": "Verify the Facility Name column", "status": "broken", "statusDetails": {"message": "KeyError: 'Facility Name'\n", "trace": "  File \"C:\\Users\\Vijay.Sriramoju.CTR\\Anaconda3\\envs\\FuzzyNameMatching\\lib\\site-packages\\allure_commons\\_allure.py\", line 172, in impl\n    return func(*a, **kw)\n  File \"C:\\Work_Imp\\DataScience\\FuzzyMatcherVENV\\tests\\csvfilecheck.py\", line 63, in test_Facility_Name\n    dt.validate.regex(df['Facility Name'],r'^[a-zA-Z0-9()]')\n  File \"C:\\Users\\Vijay.Sriramoju.CTR\\Anaconda3\\envs\\FuzzyNameMatching\\lib\\site-packages\\pandas\\core\\frame.py\", line 3455, in __getitem__\n    indexer = self.columns.get_loc(key)\n  File \"C:\\Users\\Vijay.Sriramoju.CTR\\Anaconda3\\envs\\FuzzyNameMatching\\lib\\site-packages\\pandas\\core\\indexes\\base.py\", line 3363, in get_loc\n    raise KeyError(key) from err\n"}, "parameters": [{"name": "df", "value": "      Account_Num  ...              Hospital Ownership\n0           10605  ...  Voluntary non-profit - Private\n1           24250  ...                     Proprietary\n2           10341  ...  Voluntary non-profit - Private\n3           81101  ...                     Proprietary\n4           39835  ...                     Proprietary\n...           ...  ...                             ...\n5334        92281  ...  Voluntary non-profit - Private\n5335        65248  ...  Voluntary non-profit - Private\n5336        92377  ...              Government - State\n5337        71562  ...    Voluntary non-profit - Other\n5338        51586  ...                     Proprietary\n\n[5339 rows x 10 columns]"}], "start": 1631235074305, "stop": 1631235074305}], "start": 1631235074294, "stop": 1631235074312, "uuid": "559d0e7a-b2f5-478c-bb16-5f3b36c07829", "historyId": "183feabf3ba307bd6e0a90125255da30", "testCaseId": "5bc1938d80011159b4d87b8a8078517c", "fullName": "csvfilecheck#test_Facility_Name", "labels": [{"name": "severity", "value": "minor"}, {"name": "suite", "value": "csvfilecheck"}, {"name": "host", "value": "DOA-DOIT-CONSL1"}, {"name": "thread", "value": "15952-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "csvfilecheck"}]}